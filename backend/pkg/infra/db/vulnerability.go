package db

import (
	"fmt"
	"time"

	"github.com/guregu/dynamo"
	"github.com/m-mizutani/goerr"
	"github.com/m-mizutani/octovy/backend/pkg/model"
)

const vulnerabilityTimeKey = "2006-01-02T15:04:05"

func vulnerabilityPK() string {
	return "list:vulnerability"
}
func vulnerabilitySK(vulnID string) string {
	return vulnID
}
func vulnerabilityPK2() string {
	return "list:vulnerability"
}
func vulnerabilitySK2(firstSeenAt int64, vulnID string) string {
	return fmt.Sprintf("%s/%s", time.Unix(firstSeenAt, 0).Format(vulnerabilityTimeKey), vulnID)
}

func (x *DynamoClient) InsertVulnerability(vuln *model.Vulnerability) error {
	// TODO: Check if record exists before put operation to use R/W capacity more efficiently
	record := &dynamoRecord{
		PK:  vulnerabilityPK(),
		SK:  vulnerabilitySK(vuln.VulnID),
		PK2: vulnerabilityPK2(),
		SK2: vulnerabilitySK2(vuln.FirstSeenAt, vuln.VulnID),
		Doc: vuln,
	}

	q := x.table.Put(record).If("attribute_not_exists(pk) AND attribute_not_exists(sk)")
	if err := q.Run(); err != nil {
		if !isConditionalCheckErr(err) {
			return goerr.Wrap(err).With("record", record)
		}

		// Record exists, then update vulnerability info
		update := x.table.Update("pk", record.PK).
			Range("sk", record.SK).
			Set("doc.'Detail'", vuln.Detail).
			Set("doc.'LastModifiedAt'", vuln.LastModifiedAt).
			If("doc.'LastModifiedAt' < ?", vuln.LastModifiedAt)

		if err := update.Run(); err != nil {
			if !isConditionalCheckErr(err) {
				return goerr.Wrap(err)
			}
		}
	}

	return nil
}

func (x *DynamoClient) FindVulnerability(vulnID string) (*model.Vulnerability, error) {
	var record *dynamoRecord
	pk := vulnerabilityPK()
	sk := vulnerabilitySK(vulnID)
	if err := x.table.Get("pk", pk).Range("sk", dynamo.Equal, sk).One(&record); err != nil {
		if !isNotFoundErr(err) {
			return nil, goerr.Wrap(err).With("pk", pk).With("sk", sk)
		}
		return nil, nil
	}

	var vuln model.Vulnerability
	if err := record.Unmarshal(&vuln); err != nil {
		return nil, err
	}

	return &vuln, nil
}

func (x *DynamoClient) FindLatestVulnerabilities(n int) ([]*model.Vulnerability, error) {
	var records []*dynamoRecord
	pk2 := vulnerabilityPK2()
	if err := x.table.Get("pk2", pk2).Index(dynamoGSIName2nd).Order(dynamo.Descending).Limit(int64(n)).All(&records); err != nil {
		if !isNotFoundErr(err) {
			return nil, goerr.Wrap(err)
		}
		return nil, nil
	}

	vulns := make([]*model.Vulnerability, len(records))
	for i := range records {
		if err := records[i].Unmarshal(&vulns[i]); err != nil {
			return nil, err
		}
	}

	return vulns, nil

}
